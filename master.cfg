# -*- python -*-
# ex: set filetype=python:

from future.utils import iteritems
from future.utils import string_types
from buildbot.process.build import Build
from buildbot.plugins import *
from buildbot.process import logobserver
from buildbot import locks
from twisted.python import log
from twisted.internet import defer
import buildbot
import subprocess, re, json
import os.path
from buildbot.steps.worker import CompositeStepMixin
from buildbot.www.hooks.github import GitHubEventHandler
from datetime import timedelta
from datetime import datetime

import utils
from builds import Builds

builds = Builds('builds.json')

f = open('config.json', 'r')
config = utils.json_to_ascii(json.loads(f.read ()))

def getConfig(name, default=""):
    return config.get(name, default)

def getConfigv(name, default=[]):
    return config.get(name, default)

flathub_buildbot_port = getConfig('buildbot-port', 8010)
flathub_num_master_workers = getConfig('num-master-workers', 4)
flathub_buildbot_uri = getConfig('buildbot-uri')
flathub_upstream_repo = getConfig('flathub-repo')
flathub_upstream_repo_path = getConfig('flathub-repo-path')
flathub_branch = getConfig('flathub-branch')
flathub_gpg_homedir = getConfig('flathub-gpg-homedir')
flathub_gpg_key = getConfig('flathub-gpg-key')
flathub_admin_password = getConfig('admin-password')
flathub_github_auth_client = getConfig('github-auth-client')
flathub_github_auth_secret = getConfig('github-auth-secret')
flathub_github_change_secret = getConfig('github-change-secret')
flathub_gitlab_change_secret = getConfig('gitlab-change-secret')
flathub_github_status_token = getConfig('github-status-token')
flathub_keep_builds = getConfig('keep-builds', False)
flathub_db_uri = getConfig('db-uri', "sqlite:///state.sqlite")

# Buildbot does unique builds per build + worker, so if we want a single worker
# to build multiple apps of the same arch, then we need to have multiple build
# ids for each arch, so we append a number which we calculate from the build id
num_builders_per_arch = flathub_num_master_workers

# Tracks the last build number that was used to update the repo for a particular build-id
# So we avoid going backwards if the builds finish in the wrong order
flathub_build_latest_update = {}

f = open('builders.json', 'r')
worker_config = utils.json_to_ascii(json.loads(f.read ()))

###### Init

c = BuildmasterConfig = {}
c['change_source'] = []
c['protocols'] = {}

####### Authentication

auth = None
roleMatchers=[]
adminsRole="admins"

if flathub_admin_password != '':
    auth = util.UserPasswordAuth({"admin": flathub_admin_password})
    roleMatchers.append(util.RolesFromEmails(admins=["admin"]))

if flathub_github_auth_client != '':
    auth = util.GitHubAuth(flathub_github_auth_client, flathub_github_auth_secret)
    roleMatchers.append(util.RolesFromGroups())
    adminsRole = 'flathub'

authz = util.Authz(
    allowRules=[
        util.AnyControlEndpointMatcher(role=adminsRole)
    ],
    roleMatchers=roleMatchers
)

c['protocols']['pb'] = {'port': 9989}

####### SETUP

flathub_arches = []
flathub_arch_workers = {}
flathub_update_workers = []

gpg_args = []
if flathub_gpg_key:
    gpg_args.append ('--gpg-sign=' + flathub_gpg_key)
if flathub_gpg_homedir:
    gpg_args.append ('--gpg-homedir=' + flathub_gpg_homedir)

####### WORKERS

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.
c['workers'] = []

# For whatever reason, max-builds doesn't seem to work, so we only ever run one build.
# To hack around this we create multiple master workers
local_workers = []
for i in range(1,flathub_num_master_workers+1):
    name = 'MasterWorker%d' % i
    c['workers'].append (worker.LocalWorker(name))
    local_workers.append(name)

build_workers = []

for w in worker_config.iterkeys():
    wc = worker_config[w]
    passwd = wc['password']
    max_builds = 1
    if wc.has_key('max-builds'):
        max_builds = wc['max-builds']
    wk = worker.Worker(w, passwd, max_builds=max_builds)
    wk.flathub_classes = []
    if wc.has_key('classes'):
        wk.flathub_classes = wc['classes']
    c['workers'].append (wk)
    if wc.has_key('arches'):
        build_workers.append(w)
        for a in wc['arches']:
            if not a in flathub_arches:
                flathub_arches.append(a)
                flathub_arch_workers[a] = []
            flathub_arch_workers[a].append(w)
    if wc.has_key('update-repo'):
        flathub_update_workers.append(w)


def change_should_build(change):
    try:
        log.msg("Should we build change: %s" % (change))
        forced_id = None
        if change.project.startswith("forced-build-id-"):
            forced_id = change.project[len("forced-build-id-"):]
        info = builds.lookup_by_git(change.repository, change.branch, forced_id)
        if info:
            return info.official or change.category == 'bot-build'
    except:
        pass
    return False

####### SCHEDULERS
checkin = schedulers.AnyBranchScheduler(name="checkin",
                                        treeStableTimer=10,
                                        change_filter=util.ChangeFilter(filter_fn=change_should_build),
                                        builderNames=["Build App"])

def getArchBuilderName(arch, buildnr):
    b = buildnr % num_builders_per_arch
    if b == 0:
        build_extra = ""
    else:
        build_extra = "-%s" % b

    return "build-" + arch + build_extra

@util.renderer
def computeBuildArches(props):
    buildnr = props.getProperty ('flathub-buildnumber', 0)
    return map(lambda arch: getArchBuilderName(arch, buildnr), props.getProperty("flathub-arches", []))

build = schedulers.Triggerable(name="build-all-platforms",
                               builderNames=computeBuildArches)
update_repo = schedulers.Triggerable(name="update-repo",
                                     builderNames=["update-repo"])

class AppParameter(util.CodebaseParameter):

    """A parameter whose result is a codebase specification instead of a property"""
    type = util.CodebaseParameter.type
    codebase = ''

    def __init__(self,
                 codebase,
                 name=None,
                 label=None,
                 **kwargs):

        util.CodebaseParameter.__init__(self, name=name, label=label,
                                        codebase=codebase,
                                        branch=util.StringParameter(name="branch", label='branch:', default=""),
                                        revision=util.FixedParameter(name="revision", default=""),
                                        repository=util.StringParameter(name="repository", label='repo uri:', default=""),
                                        project=util.FixedParameter(name="project", default=""),
                                        **kwargs)

    def createSourcestamp(self, properties, kwargs):
        cb = kwargs.get(self.fullName, [])
        branch = cb['branch']
        buildname = kwargs.get('buildname', None)[0]
        repo_uri = cb['repository']
        if repo_uri:
            if '/' in buildname:
                raise Exception("Can't specify non-empty version and custom git repo at the same time.")
            # Here, buildname is now always just an id
            data = builds.lookup_by_git(repo_uri, branch if branch else "master", buildname)
            # If we specified a custom git uri then the git module name might not be the
            # app id, so in this case we need to remember the actual app id that
            # the user specified
            if buildname:
                project = 'forced-build-id-%s' % data.id
            else:
                project = 'flathub-' + data.id
        elif buildname:
            data = builds.lookup_by_name(buildname)
            project = 'flathub-' + data.id
            if branch:
                data.git_branch = branch
                # We're overriding the branch, so we loose officialness
                data.official = False
        else:
            raise Exception("Must specify either repo uri or buildname")

        return {'project': project,
                'repository': data.url,
                'revision': '',
                'branch': data.git_branch}

force = schedulers.ForceScheduler(
    name="force",
    buttonName="Force Rebuild",
    label="Force a rebuild",
    builderNames=["Build App"],

    codebases=[
        AppParameter(
            "",
            name="Main repository",
        ),
    ],
    reason=util.StringParameter(name="reason",
                                label="reason:",
                                required=True, default="force build", size=80),
    properties=[
        util.StringParameter(name="buildname",
                             label="Buildname:",
                             required=False),
        util.StringParameter(name="force-arches",
                             label="Arches: (comma separated)",
                             required=False),
        util.BooleanParameter(name="force-test-build",
                              label="Force a test build (even for normal location)",
                              default=False)
    ]
)

c['schedulers'] = [checkin, build, update_repo, force]
c['collapseRequests'] = False

####### Custom builders

# We create one worker lock per build-id, which is the same as the workdir
# so multiple builds never work in the same workdir on any particular worker
class BuildIDLockBuild(Build):
    _workerLocks = {}

    @staticmethod
    def find_or_create_master_lock_for_buildid(buildid):
        lock = BuildIDLockBuild._workerLocks.get(buildid)
        if lock is None:
            log.msg("********* Created lock for buildid %s" % buildid)
            lock = locks.WorkerLock(buildid + ' buildid lock')
            BuildIDLockBuild._workerLocks[buildid] = lock
        return lock

    def startBuild(self, build_status, workerforbuilder):
        buildid = self.getProperty('flathub-build-id')
        lock = BuildIDLockBuild.find_or_create_master_lock_for_buildid(buildid)
        self.setLocks([lock.access('exclusive'), flatpak_worker_lock.access('counting')])
        return Build.startBuild(self, build_status, workerforbuilder)

####### BUILDERS

def hide_on_success(results, s):
    return results==buildbot.process.results.SUCCESS

def hide_on_skipped(results, s):
    return results==buildbot.process.results.SKIPPED

def hide_on_success_or_skipped(results, s):
    return results==buildbot.process.results.SUCCESS or results==buildbot.process.results.SKIPPED

# Official builds are master branch on the canonical flathub git repo
def BuildIsOfficial(step):
    return step.build.getProperty ('flathub-official-build', False)

flatpak_update_lock = util.WorkerLock("flatpak-update")
# This lock is taken in a shared mode for builds, but in exclusive mode when doing
# global worker operations like cleanup
flatpak_worker_lock = util.WorkerLock("flatpak-worker-lock", maxCount=1000)
import_lock = util.MasterLock("import")
repo_lock = util.MasterLock("repo")

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which workers can execute them.  Note that any particular build will
# only take place on one worker.

class MaybeAddSteps(steps.BuildStep):
    parms = steps.BuildStep.parms + ['steps']
    steps = None
    predicate = None

    def __init__(self, predicate, **kwargs):
        for p in self.__class__.parms:
            if p in kwargs:
                setattr(self, p, kwargs.pop(p))

        steps.BuildStep.__init__(self, **kwargs)
        self.predicate = predicate

    def run(self):
        if self.predicate(self.build):
            self.build.addStepsAfterCurrentStep(self.steps)
        return buildbot.process.results.SUCCESS

def shellArgOptional(commands):
    return util.ShellArg(logfile='stdio', command=commands)

def shellArg(commands):
    return util.ShellArg(logfile='stdio', haltOnFailure=True, command=commands)

class TitleObserver(logobserver.LogObserver):
    title_re = re.compile (r"\x1b]2;[\s\w!/\\#$%&'*+-.^_`|~:~]*\x07")

    def __init__(self):
        pass

    def gotData(self, stream, data):
        if data:
            for m in self.title_re.findall(data):
                title = m[4:-1]
                self.step.setTitle(title)


class FlatpakBuildStep(buildbot.process.buildstep.ShellMixin, steps.BuildStep):
    def __init__(self, **kwargs):
        self.setupShellMixin({'logEnviron': False,
                              'timeout': 3600,
                              'usePTY': True})
        steps.BuildStep.__init__(self, haltOnFailure = True, **kwargs)
        self.addLogObserver('stdio', TitleObserver())
        self.title = u"Building"

    @defer.inlineCallbacks
    def run(self):
        props = self.build.properties
        id = props.getProperty("flathub-id")
        self.title = u"Building %s.json" % id
        self.result_title = u"Failed to build %s.json" % id
        self.updateSummary()

        command = ['flatpak-builder', '-v', '--force-clean', '--sandbox', '--delete-build-dirs',
                   '--user', '--install-deps-from=flathub',
                   util.Property('extra-fb-args'),
                   '--mirror-screenshots-url=https://flathub.org/repo/screenshots', '--repo', 'repo',
                   util.Interpolate('--extra-sources=%(prop:builddir)s/../downloads'),
                   '--default-branch', util.Property('flathub-branch'),
                   '--subject', util.Property('flathub-subject'),
                   'builddir', util.Interpolate('%(prop:flathub-manifest)s')]
        if props.getProperty("flathub-custom-buildcmd", False):
            command = ['./build.sh', util.Property('flathub-arch'), 'repo', '', util.Interpolate('--sandbox --delete-build-dirs --user --install-deps-from=flathub --extra-sources=%(prop:builddir)s/../downloads '), util.Property('flathub-subject')]

        rendered=yield self.build.properties.render(command)
        cmd = yield self.makeRemoteShellCommand(command=rendered)
        yield self.runCommand(cmd)

        if not cmd.didFail():
            self.result_title = u"Built %s.json" % id

        defer.returnValue(cmd.results())

    def setTitle(self, title):
        if title.startswith("flatpak-builder: "):
            title = title[17:]
        self.title = title
        self.updateSummary()

    def getCurrentSummary(self):
        return {u'step': self.title}

    def getResultSummary(self):
        return {u'step': self.result_title}

def create_build_factory():
    build_factory = util.BuildFactory()
    build_factory.buildClass = BuildIDLockBuild
    build_factory.workdir = util.Property('flathub-build-id')
    build_factory.addSteps([
        steps.Git(name="checkout manifest",
                  logEnviron=False,
                  repourl=util.Property('repository'),
                  mode='incremental', branch='master', submodules=True),
        steps.ShellSequence(
            name='Init',
            haltOnFailure=True,
            logEnviron=False,
            commands=[
                # Always do this because we upload the repo, even if its empty if we don't build this arch
                shellArg(['rm', '-rf', 'parent-repo', 'repo', 'repo.tar']),
                shellArg(['ostree', '--repo=repo', '--mode=archive-z2', 'init']),
                shellArg(['mkdir', '-p', 'repo/screenshots']),
                # Clean up rofiles-fuse
                shellArg('for i in .flatpak-builder/rofiles/rofiles-*/; do fusermount -u $i; done || true')
                ]),
        steps.FileDownload(name='downloading public key',
                           haltOnFailure=True,
                           hideStepIf=hide_on_success,
                           mastersrc="flathub.gpg",
                           workerdest="flathub.gpg"),
        steps.ShellSequence(
            name='Prepare for build',
            haltOnFailure=True,
            logEnviron=False,
            commands=[
                # Add flathub remote
                shellArg(['flatpak', '--user', 'remote-add', '--if-not-exists', '--gpg-import=flathub.gpg',
                          'flathub', flathub_upstream_repo]),
                # Update flathub remote url
                shellArg(['flatpak', '--user', 'remote-modify', '--url='+ flathub_upstream_repo, 'flathub']),
            ]),
        FlatpakBuildStep(name='Build'),
        steps.ShellCommand(
            name='Check for AppStream xml',
            doStepIf=lambda step: not step.build.getProperty('flathub-config', {}).get("skip-appstream-check"),
            haltOnFailure=True,
            logEnviron=False,
            command=util.Interpolate('stat builddir/*/share/app-info/xmls/%(prop:flathub-id)s.xml.gz')),
        steps.ShellCommand(
            name='Check for right id in AppStream xml',
            doStepIf=lambda step: not step.build.getProperty('flathub-config', {}).get("skip-appstream-check"),
            haltOnFailure=True,
            logEnviron=False,
            command=util.Interpolate('zgrep "<id>%(prop:flathub-id)s\\(.desktop\\)\\?</id>" builddir/*/share/app-info/xmls/%(prop:flathub-id)s.xml.gz')),
        steps.ShellCommand(
            name='Check that the right branch was built',
            haltOnFailure=True,
            logEnviron=False,
            command=util.Interpolate('test ! -d repo/refs/heads/app -o -f repo/refs/heads/app/%(prop:flathub-id)s/%(prop:flathub-arch)s/%(prop:flathub-branch)s')),
        # Copy the previous flathub commit to a local repo so we can use it as the parent
        steps.ShellSequence(
            name='Download previous revision',
            doStepIf=BuildIsOfficial,
            logEnviron=False,
            haltOnFailure=True,
            commands=[
                # We use bare-user mode so that the deltas work
                shellArg(['ostree', '--repo=flathub-repo', 'init', '--mode=bare-user']),
                shellArg(['ostree', 'remote', 'add', '--repo=flathub-repo', '--gpg-import=flathub.gpg', 'origin', flathub_upstream_repo]),
                shellArg('for ref in `ostree --repo=repo refs | grep -v appstream`; do echo "$ref"; ostree --repo=flathub-repo pull --mirror --disable-fsync origin "$ref" || true; done')
            ]),
        steps.ShellSequence(
            name='Rebase build on previous revision',
            logEnviron=False,
            doStepIf=BuildIsOfficial,
            haltOnFailure=True,
            commands=[
                # Merge the two into a new repo
                shellArg(['ostree', '--repo=merged-repo', 'init', '--mode=archive-z2']),
                shellArg(['ostree', 'pull-local', '--repo=merged-repo', 'flathub-repo']),
                shellArg(['rm', '-rf', 'flathub-repo']),
                shellArg(['flatpak', 'build-commit-from', '--src-repo=repo', 'merged-repo']),
                # Switch merged-repo to 'repo', which is later packed up as the build result
                shellArg(['rm', '-rf', 'repo']),
                shellArg(['mv', 'merged-repo', 'repo'])
            ]),
        steps.ShellCommand(
            name='Generate static deltas',
            logEnviron=False,
            doStepIf=BuildIsOfficial,
            timeout=10000,
            warnOnFailure=True,
            command=['flatpak', 'build-update-repo', '--generate-static-deltas', 'repo']),
        steps.ShellSequence(
            name='Post-build work',
            haltOnFailure=True,
            logEnviron=False,
            doStepIf=BuildIsOfficial,
            commands=[
                # Remove unreferenced objects to avoid uploading them
                shellArg(['ostree', 'prune', '--repo=repo', '--refs-only', '--depth=0']),
                # Ensure directories are there
                shellArg(['mkdir', '-p', 'builddir/screenshots']),
                # Copy screenshots
                shellArg(['cp', '-r', 'builddir/screenshots', 'repo/'])
            ]),
        steps.ShellCommand(name='packaging result',
                           haltOnFailure=True,
                           doStepIf=BuildIsOfficial,
                           hideStepIf=hide_on_skipped,
                           logEnviron=False,
                           command=['tar', 'cf', 'repo.tar', 'repo']),
        steps.FileUpload(workersrc='repo.tar',
                         haltOnFailure=True,
                         doStepIf=BuildIsOfficial,
                         hideStepIf=hide_on_skipped,
                         masterdest=util.Interpolate('%(prop:flathub-artifact-dir)s/%(prop:flathub-arch)s-repo.tar'),
                         blocksize=512*1024),
        steps.FileDownload(name='downloading merge-sources.sh',
                           haltOnFailure=True,
                           hideStepIf=hide_on_success,
                           mode=0755,
                           mastersrc="scripts/merge-sources.sh",
                           workerdest="merge-sources.sh"),
        steps.ShellCommand(name='stash downloads',
                           logEnviron=False,
                           warnOnFailure=True,
                           command=['./merge-sources.sh', util.Interpolate('%(prop:builddir)s/../downloads')]),
        steps.ShellCommand(name='clean up',
                           alwaysRun=True,
                           logEnviron=False,
                           command=['rm', '-rf',
                                    '.flatpak-builder/build' if flathub_keep_builds else '.flatpak-builder',
                                    'builddir', 'repo', 'flathub-repo', 'merged-repo', 'repo.tar'])
    ])
    return build_factory

class BuildDependenciesSteps(steps.BuildStep):
    parms = steps.BuildStep.parms

    def __init__(self,  **kwargs):
        for p in self.__class__.parms:
            if p in kwargs:
                setattr(self, p, kwargs.pop(p))

        steps.BuildStep.__init__(self, **kwargs)

    @defer.inlineCallbacks
    def run(self):
        buildid = self.build.getProperty ('flathub-build-id', "").replace("@","/")
        buildnr = self.build.getProperty ('flathub-buildnumber', 0)
        deps = builds.reverse_dependency_lookup(buildid)
        for d in deps:
            change = yield self.master.data.updates.addChange(
                author = u"flathub",
                comments = u'Rebuild triggered by %s build %s\n' % (buildid, buildnr),
                project = 'forced-build-id-%s' % d.id,
                branch = d.git_branch,
                repository = d.url,
                category = "build-dependency"
            )

        defer.returnValue(buildbot.process.results.SUCCESS)

class AddArchSteps(steps.BuildStep):
    parms = steps.BuildStep.parms
    steps = None

    def __init__(self, **kwargs):
        for p in self.__class__.parms:
            if p in kwargs:
                setattr(self, p, kwargs.pop(p))

        steps.BuildStep.__init__(self, **kwargs)

    def run(self):
        arches = self.build.getProperty("flathub-arches", [])
        for arch in arches:
            arch = utils.asciiize(arch)
            self.build.addStepsAfterCurrentStep(
                [
                    steps.FileDownload(name='download ' + arch + ' build result',
                                       mastersrc=util.Interpolate('%(prop:flathub-artifact-dir)s/'+arch+'-repo.tar'),
                                       haltOnFailure=True,
                                       workerdest=arch+'-repo.tar',
                                       blocksize=512*1024),
                    steps.ShellSequence(name='Extract ' + arch + ' build results',
                                        haltOnFailure=True,
                                        logEnviron=False,
                                        commands=[
                                            shellArg(['tar', 'xf', arch+'-repo.tar']),
                                            shellArg(['rm', arch+'-repo.tar'])
                                        ])
                ])
        return buildbot.process.results.SUCCESS

    def getResultSummary(self):
        r = {}
        r[u'build'] =  u"%s" % (self.build.getProperty("flathub-desc", "?"))
        return r

update_repo_factory = util.BuildFactory()
update_repo_factory.addSteps([
    steps.ShellCommand(name='clean old repo',
                       haltOnFailure=True,
                       logEnviron=False,
                       command=['rm', '-rf', 'repo', 'import-repo']),
    AddArchSteps(name="Download results"),
    steps.MasterShellCommand(name='remove build results from master',
                             command=['rm', '-rf', util.Interpolate('%(prop:flathub-artifact-dir)s')],
                             alwaysRun=True),
    steps.ShellSequence(name='Check and prepare repo',
                        logEnviron=False,
                        haltOnFailure=True,
                        env={ 'GPGME_DEBUG' : '9' },
                        commands=[
        # Ensure files are readable
        shellArg(['chmod', '-R', 'a+rX', 'repo']),
        # Fsck repo we got from builders
        shellArg(['ostree', '--repo=repo', 'fsck']),
        # Create new repo we will import from
        shellArg(['ostree', '--repo=import-repo', '--mode=archive-z2', 'init']),
        shellArg(['ostree', '--repo=import-repo', 'config', 'set', 'core.parent', flathub_upstream_repo_path]),
        # Create signed commits in the import repo
        shellArg(['flatpak', 'build-commit-from', '--src-repo=repo', '--no-update-summary'] + gpg_args + ["import-repo"])
                        ]),
    steps.ShellSequence(name='Merge to main repo and update',
                        logEnviron=False,
                        haltOnFailure=True,
                        timeout=10000,
                        locks=[repo_lock.access('exclusive')],
                        commands=[
                            shellArg(['rsync', '-rltv', '--ignore-existing',
                                      'repo/screenshots/', flathub_upstream_repo_path + '/screenshots/']),
                            shellArg(['mkdir', '-p', 'import-repo/deltas']),# Ensure its there
                            shellArg(['rsync', '-rltv', '--ignore-existing',
                                      'import-repo/deltas/', flathub_upstream_repo_path + '/deltas/']),
                            shellArg(['ostree', 'pull-local', '-v', '--repo=' + flathub_upstream_repo_path, 'import-repo']),
                            shellArg(['flatpak', 'build-update-repo', '--generate-static-deltas'] + gpg_args + [flathub_upstream_repo_path])],),
    steps.ShellCommand(name='clean up',
                       logEnviron=False,
                       command=['rm', '-rf', 'repo', 'import-repo']),
    steps.FileDownload(name='downloading update-appdata.sh',
                       haltOnFailure=True,
                       hideStepIf=hide_on_success,
                       mode=0755,
                       mastersrc="scripts/update-appdata.sh",
                       workerdest="update-appdata.sh"),
    steps.ShellCommand(name='update appdata',
                       logEnviron=False,
                       command=['./update-appdata.sh', flathub_upstream_repo_path]),
    BuildDependenciesSteps(name='build dependencies')
])

def asciiBasename(s):
    return utils.asciiize(os.path.basename(s))

class FlathubPropertiesStep(steps.BuildStep, CompositeStepMixin):
    def __init__(self, **kwargs):
        steps.BuildStep.__init__(self, **kwargs)

    @defer.inlineCallbacks
    def run(self):
        props = self.build.properties

        flathub_config = {}
        content = yield self.getFileContentFromWorker("flathub.json")
        if content != None:
            flathub_config = json.loads(content)

        git_subject = props.getProperty('git-subject')
        buildnumber = props.getProperty('buildnumber')
        repository = props.getProperty('repository')
        force_test_build = props.getProperty ('force-test-build', False)
        branch = props.getProperty('branch')
        project = props.getProperty('project')
        # When you force a build you can get a different app id than the repo module,
        # we have to save the specified id in the sourcestamps so we can pull it
        # back out here, so we
        forced_id = None
        if project.startswith("forced-build-id-"):
            forced_id = project[len("forced-build-id-"):]
        data = builds.lookup_by_git(repository, branch, forced_id)
        if data.fp_branch:
            buildid = "%s@%s" % (data.id, data.fp_branch)
            builddesc = "%s %s" % (data.id, data.fp_branch)
        else:
            buildid = data.id
            builddesc = data.id

        force_arches = props.getProperty("force-arches", None)
        if force_arches:
            arches = set()
            for arch in force_arches.split(","):
                arches.add(utils.asciiize(arch.strip()))
            arches = arches & set(flathub_arches)
        else:
            arches = set(flathub_arches)
            if data.only_arches:
                arches = arches & set(data.only_arches)

            if flathub_config.has_key("only-arches"):
                arches = arches & set(flathub_config["only-arches"])

            if flathub_config.has_key("skip-arches"):
                arches = arches - set(flathub_config["skip-arches"])

        # This works around the fact that we can't pass on an empty dict
        if not flathub_config:
            flathub_config["empty"] = True

        p = {
            "flathub-id": data.id,
            "flathub-subject": "%s (%s)" % (git_subject, props.getProperty('got_revision')[:8]),
            "flathub-arches": list(arches),
            "flathub-build-id": buildid,
            "flathub-buildnumber": buildnumber,
            "flathub-manifest": data.get_manifest(),
            "flathub-branch": data.fp_branch if data.fp_branch else flathub_branch ,
            "flathub-custom-buildcmd": data.custom_buildcmd,
            "flathub-official-build": data.official and not force_test_build,
            "flathub-artifact-dir": "builds/%s-%s" % (buildid, buildnumber),
            "flathub-desc": builddesc,
            "flathub-config": flathub_config
        }

        for k, v in iteritems(p):
            self.setProperty(k, v, self.name, runtime=True)

        defer.returnValue(buildbot.process.results.SUCCESS)

    def getResultSummary(self):
        return { u'build': u"%s" %
                 (self.build.getProperty("flathub-desc", "?")) }

def ShouldUpdateRepo(step):
    if not BuildIsOfficial(step):
        return False
    buildid = step.build.getProperty ('flathub-build-id', "")
    buildnumber = step.build.getProperty ('flathub-buildnumber', 0)
    last_update = flathub_build_latest_update.get(buildid, 0)
    if buildnumber >= last_update:
        flathub_build_latest_update[buildid] = buildnumber
        return True
    return False

build_app_factory = util.BuildFactory()
build_app_factory.addSteps([
    steps.Git(name="checkout manifest",
              repourl=util.Property('repository'),
              mode='incremental', branch='master', submodules=False, logEnviron=False),
    steps.SetPropertyFromCommand(command="git show --format=%s -s $(git rev-list --no-merges -n 1 HEAD)",
                                 property="git-subject", logEnviron=False),
    FlathubPropertiesStep(name="Set flathub properties"),
    steps.Trigger(name='Build all platforms',
                  haltOnFailure=True,
                  schedulerNames=['build-all-platforms'],
                  updateSourceStamp=True,
                  waitForFinish=True,
                  set_properties={
                      'flathub-id' : util.Property('flathub-id'),
                      'flathub-arches' : util.Property('flathub-arches'),
                      'flathub-build-id' : util.Property('flathub-build-id'),
                      'flathub-buildnumber' : util.Property('flathub-buildnumber'),
                      'flathub-artifact-dir' : util.Property('flathub-artifact-dir'),
                      'flathub-manifest' : util.Property('flathub-manifest'),
                      'flathub-branch' : util.Property('flathub-branch'),
                      'flathub-custom-buildcmd' : util.Property('flathub-custom-buildcmd'),
                      'flathub-official-build' : util.Property('flathub-official-build'),
                      'flathub-desc' : util.Property('flathub-desc'),
                      'flathub-config' : util.Property('flathub-config'),
                      'flathub-subject' : util.Property('flathub-subject'),
                      'reason' : util.Property('reason')
                  }),
    steps.Trigger(name='Update repository',
                  haltOnFailure=True,
                  doStepIf=ShouldUpdateRepo,
                  hideStepIf=hide_on_skipped,
                  schedulerNames=['update-repo'],
                  updateSourceStamp=True,
                  waitForFinish=True,
                  set_properties={
                      'flathub-id' : util.Property('flathub-id'),
                      'flathub-arches' : util.Property('flathub-arches'),
                      'flathub-build-id' : util.Property('flathub-build-id'),
                      'flathub-buildnumber' : util.Property('flathub-buildnumber'),
                      'flathub-artifact-dir' : util.Property('flathub-artifact-dir'),
                      'flathub-manifest' : util.Property('flathub-manifest'),
                      'flathub-branch' : util.Property('flathub-branch'),
                      'flathub-custom-buildcmd' : util.Property('flathub-custom-buildcmd'),
                      'flathub-official-build' : util.Property('flathub-official-build'),
                      'flathub-desc' : util.Property('flathub-desc'),
                      'flathub-subject' : util.Property('flathub-subject'),
                      'reason' : util.Property('flathub-buildnumber')
                  }),
    steps.MasterShellCommand(name="Clean up storage on master",
                             alwaysRun=True,
                             hideStepIf=hide_on_success_or_skipped,
                             doStepIf=BuildIsOfficial,
                             haltOnFailure=True,
                             command=['rm', '-rf', util.Interpolate('%(prop:flathub-artifact-dir)s')])
])

c['builders'] = []

status_builders = []

build_factory = create_build_factory()

def canStartBuild(builder, wfb, build):
    classes = build.properties.getProperty ('flathub-config', {}).get("classes", [])
    worker_classes = wfb.worker.flathub_classes
    if not classes:
        return True # Not specified, matches any (or none)
    for c in classes:
        if utils.asciiize(c) in worker_classes:
            return True
    return False

for arch in flathub_arches:
    extra_fb_args = ['--arch', arch]
    if arch == 'x86_64':
        extra_fb_args = extra_fb_args + ['--bundle-sources']

    for i in range(0, num_builders_per_arch):
        c['builders'].append(
            util.BuilderConfig(name=getArchBuilderName(arch, i),
                               canStartBuild=canStartBuild,
                               workernames=flathub_arch_workers[arch],
                               properties={'flathub-arch': arch, 'extra-fb-args': extra_fb_args },
                               factory=build_factory))
    status_builders.append('build-' + arch)
c['builders'].append(
    util.BuilderConfig(name='update-repo',
                       workernames=flathub_update_workers,
                       factory=update_repo_factory))
status_builders.append('update-repo')
c['builders'].append(
    util.BuilderConfig(name='Build App',
                       collapseRequests=True,
                       workernames=local_workers,
                       factory=build_app_factory))

##########################
# Builder cleanup support
##########################

force_cleanup = schedulers.ForceScheduler(
    name="force-cleanup",
    buttonName="Force cleanup",
    label="Force a worker cleanup",
    builderNames=["Cleanup Workers"],

    codebases=[util.CodebaseParameter(codebase='', hide=True)],
    reason=util.StringParameter(name="reason",
                                label="reason:",
                                required=True, default="force clean", size=80),
    properties=[
        util.StringParameter(name="cleanup-worker", label="Worker: (empty for all)", required=False),
    ]
)

@util.renderer
def computeCleanupWorkers(props):
    clean_worker = props.getProperty ('cleanup-worker', None)
    if clean_worker and clean_worker in build_workers:
        workers = [clean_worker]
    else:
        workers = build_workers

    return map(lambda x: "cleanup-" + x, workers)

cleanup = schedulers.Triggerable(name="cleanup-all-workers",
                                 builderNames=computeCleanupWorkers)

c['schedulers'].append(cleanup)
c['schedulers'].append(force_cleanup)

cleanup_factory = util.BuildFactory()
cleanup_factory.addSteps([
    steps.FileDownload(name='downloading cleanup.sh',
                       haltOnFailure=True,
                       hideStepIf=hide_on_success,
                       mode=0755,
                       mastersrc="scripts/cleanup.sh",
                       workerdest="cleanup.sh"),
    steps.ShellCommand(
        name='Status',
        logEnviron=False,
        command='./cleanup.sh')
    ])

cleanup_all_factory = util.BuildFactory()
cleanup_all_factory.addSteps([
    steps.Trigger(name='Clean up all workers',
                  schedulerNames=['cleanup-all-workers'],
                  waitForFinish=True,
                  set_properties={
                      "cleanup-worker" : util.Property('cleanup-worker')
                  })
])

for worker in build_workers:
    c['builders'].append(
        util.BuilderConfig(name='cleanup-' + worker,
                           workername=worker,
                           locks=[flatpak_worker_lock.access('exclusive')],
                           factory=cleanup_factory))
    status_builders.append('build-' + arch)

c['builders'].append(
    util.BuilderConfig(name='Cleanup Workers',
                       collapseRequests=True,
                       workernames=local_workers,
                       factory=cleanup_all_factory))

##########################
# Repo import support
##########################

force_import = schedulers.ForceScheduler(
    name="import",
    buttonName="Import",
    label="Import",
    builderNames=["Import"],

    codebases=[util.CodebaseParameter(codebase='', hide=True)],
    properties=[
        util.StringParameter(name="import-remote", label="Remote:", required=True),
        util.StringParameter(name="import-refs", label="Refs: (empty for default)", required=False),
    ]
)

c['schedulers'].append(force_import)

def getImportCommand(step, command):
    remote = step.build.getProperty ('import-remote', 'no-remote'),
    remote = utils.asciiize(remote[0])
    refs = step.build.getProperty ('import-refs', '')
    remote_data = builds.imports.get(remote)
    default_imports = remote_data.get('refs', [])
    if not refs:
        refs = ' '.join(default_imports)
    return ['./import.sh', command, flathub_upstream_repo_path, remote, remote_data.get("repo"), remote_data.get("key"), refs, flathub_gpg_homedir, flathub_gpg_key]

@util.renderer
def computeImportCommandImport(step):
    return getImportCommand(step, 'import')

@util.renderer
def computeImportCommandMerge(step):
    return getImportCommand(step, 'merge')

force_import_factory = util.BuildFactory()
force_import_factory.addSteps([
    steps.FileDownload(name='downloading import.sh',
                       haltOnFailure=True,
                       hideStepIf=hide_on_success,
                       mode=0755,
                       mastersrc="scripts/import.sh",
                       workerdest="import.sh"),
    steps.ShellCommand(
        name='Import',
        haltOnFailure=True,
        logEnviron=False,
        usePTY=True,
        timeout=3600,
        command=computeImportCommandImport),
    steps.ShellCommand(
        name='Merge',
        haltOnFailure=True,
        logEnviron=False,
        usePTY=True,
        locks=[repo_lock.access('exclusive')],
        timeout=3600,
        command=computeImportCommandMerge)
])

c['builders'].append(
    util.BuilderConfig(name='Import',
                       collapseRequests=True,
                       locks=[import_lock.access('exclusive')],
                       workernames=flathub_update_workers,
                       factory=force_import_factory))

# Prune repo

@util.renderer
def makeBackupName(props):
    return flathub_upstream_repo_path + "-backup-" + datetime.now().strftime("%Y-%m-%d")

prune_factory = util.BuildFactory()
prune_factory.addSteps([
    steps.ShellCommand(
        name='Backup',
        haltOnFailure=True,
        logEnviron=False,
        usePTY=True,
        locks=[repo_lock.access('exclusive')],
        timeout=10000,
        command=['cp', '-aRln', flathub_upstream_repo_path, makeBackupName]),
    steps.ShellCommand(
        name='Prune',
        haltOnFailure=True,
        logEnviron=False,
        usePTY=True,
        locks=[repo_lock.access('exclusive')],
        timeout=10000,
        command=['ostree', 'prune', '--repo='+flathub_upstream_repo_path, '--refs-only', '--depth=3'])
])

c['builders'].append(
    util.BuilderConfig(name='Prune',
                       collapseRequests=True,
                       locks=[import_lock.access('exclusive')],
                       workernames=flathub_update_workers,
                       factory=prune_factory))

force_prune = schedulers.ForceScheduler(
    name="prune",
    buttonName="Prune",
    label="Prune",
    builderNames=["Prune"],

    codebases=[util.CodebaseParameter(codebase='', hide=True)],
)
c['schedulers'].append(force_prune)

periodic_prune = schedulers.Periodic(name="PeriodicPrune",
                                     builderNames=["Prune"],
                                     periodicBuildTimer=7*24*60*60)
c['schedulers'].append(periodic_prune)




####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

c['services'] = []

if flathub_github_status_token != '':
    c['services'].append(reporters.GitHubStatusPush(token=flathub_github_status_token,
                                                    verbose=True,
                                                    context=util.Interpolate("buildbot/%(prop:buildername)s"),
                                                    startDescription='Build started.',
                                                    endDescription='Build done.',
                                                    builders=status_builders))

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').

c['title'] = 'Flathub'
c['titleURL'] = 'https://github.com/flatpak/flathub'

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server is visible. This typically uses the port number set in
# the 'www' entry below, but with an externally-visible host name which the
# buildbot cannot figure out without some help.

c['buildbotURL'] = flathub_buildbot_uri

c['www'] = dict(port=flathub_buildbot_port,
                plugins=dict(flathub_view={}),
                authz=authz)
if auth:
    c['www']['auth'] = auth

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  Here we point to the buildbot clone of pyflakes.

class FlathubGithubHandler(GitHubEventHandler):

    def handle_issue_comment(self, payload, event):
        body = payload["comment"]["body"]
        assoc = payload["comment"]["author_association"]
        issue_nr = payload["issue"]["number"]

        offset = body.find("bot, build");
        if offset == -1:
            return [], 'git'

        build_id = None
        rest = body[offset+len("bot, build"):]
        lines = rest.splitlines()
        if len(lines) > 0:
            words = lines[0].split()
            if len(words) > 0:
                build_id = words[0]

        log.msg("Detected build test request in %s PR %d (id %s)" % (payload['repository']['html_url'], issue_nr, build_id))

        if not assoc in ["COLLABORATOR", "CONTRIBUTOR", "MEMBER", "OWNER"]:
            log.msg("WARNING: Ignoring build test request due to lack of perms")
            return [], 'git'

        project = payload['repository']['full_name'].replace("/", "-")
        if build_id:
            project = 'forced-build-id-%s' % build_id
        change = {
            'branch': 'refs/pull/{}/head'.format(issue_nr),
            'repository': payload['repository']['html_url'],
            'project': project,
            'category': 'bot-build',
            'author': payload['sender']['login'],
            'comments': u'GitHub Pull Request #%d test build\n' % (issue_nr)
        }

        return [change], 'git'

c['www']['change_hook_dialects'] = { }

if flathub_github_change_secret != "":
    c['www']['change_hook_dialects']['github'] = {
        'class': FlathubGithubHandler,
        'secret': flathub_github_change_secret,
        'strict': True
    }

if flathub_gitlab_change_secret and flathub_gitlab_change_secret != "":
    c['www']['change_hook_dialects']['gitlab'] = {
        'secret': flathub_gitlab_change_secret
    }

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : flathub_db_uri,
}

# configure a janitor which will delete all logs older than one month,
# and will run on sundays at noon
c['configurators'] = [util.JanitorConfigurator(
    logHorizon=timedelta(weeks=4),
    hour=12,
    dayOfWeek=6
)]
